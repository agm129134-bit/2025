<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<title>隨機迷宮 + DFS 隨機方向</title>
<style>
  body { font-family: Arial; background:#f4f6f8; display:flex; flex-direction:column; align-items:center; padding:20px; }
  #controls { margin:10px 0; display:flex; gap:8px; align-items:center; }
  button { padding:6px 10px; }
  canvas { border:1px solid #333; background:#fff; }
</style>
</head>
<body>
<h2>隨機迷宮 + DFS 動畫（方向亂數）</h2>
<canvas id="c" width="600" height="600"></canvas>
<div id="controls">
  <button id="startBtn">Start</button>
  <button id="stepBtn">Step</button>
  <button id="stopBtn" disabled>Stop</button>
  <button id="resetBtn">Reset</button>
  <button id="regenBtn">ReGen Maze</button>
  <label>速度 <input id="speed" type="range" min="50" max="1000" step="50" value="250"></label>
</div>
<div id="status">狀態：尚未開始</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const ROWS = 51, COLS = 51;
let cellSize = canvas.width / COLS;
let MAZE;
let START = {r:1,c:1};
let END   = {r:ROWS-2,c:COLS-2};
let stack, visited, parent, current, route, found;
let timer=null;

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
}

function genMaze(){
  MAZE = Array.from({length:ROWS},()=>Array(COLS).fill(1));
  function carve(r,c){
    const dirs=[[ -2,0 ],[ 2,0 ],[ 0,-2 ],[ 0,2 ]];
    shuffle(dirs);
    MAZE[r][c]=0;
    for(const [dr,dc] of dirs){
      const nr=r+dr, nc=c+dc;
      if(nr>0 && nr<ROWS-1 && nc>0 && nc<COLS-1 && MAZE[nr][nc]===1){
        MAZE[r+dr/2][c+dc/2]=0;
        carve(nr,nc);
      }
    }
  }
  carve(1,1);
}

function resetSearch(){
  stack=[];
  visited=new Set();
  parent={};
  route=[];
  found=false;
  current=null;
  stack.push({...START});
}

function posKey(r,c){return r+","+c;}

function dfsStep(){
  if(found) return;
  if(stack.length===0){status.textContent="無解";return;}
  const node = stack.pop();
  const key = posKey(node.r,node.c);
  if(MAZE[node.r][node.c]===1) return;
  if(visited.has(key)) return;
  visited.add(key);
  current=node;
  if(node.r===END.r && node.c===END.c){found=true; reconstruct(node); return;}
  let dirs=[[ -1,0 ],[ 1,0 ],[ 0,-1 ],[ 0,1 ]];
  shuffle(dirs);
  for(const [dr,dc] of dirs){
    const nr=node.r+dr, nc=node.c+dc;
    if(nr<0||nr>=ROWS||nc<0||nc>=COLS)continue;
    if(MAZE[nr][nc]===1)continue;
    const k=posKey(nr,nc);
    if(!visited.has(k)){
      stack.push({r:nr,c:nc});
      if(parent[k]===undefined) parent[k]=key;
    }
  }
}

function reconstruct(node){
  let k=posKey(node.r,node.c);
  route=[];
  while(k!==undefined){
    const [r,c]=k.split(',').map(Number);
    route.push({r,c});
    if(k===posKey(START.r,START.c))break;
    k=parent[k];
  }
  route.reverse();
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      ctx.fillStyle = MAZE[r][c]===1 ? "#000" : "#f0f0f0";
      ctx.fillRect(c*cellSize,r*cellSize,cellSize,cellSize);
    }
  }
  for(const k of visited){
    const [r,c]=k.split(',').map(Number);
    ctx.fillStyle="#d0d0d0";
    ctx.fillRect(c*cellSize,r*cellSize,cellSize,cellSize);
  }
  if(current){
    ctx.fillStyle="#ff5555";
    ctx.fillRect(current.c*cellSize,current.r*cellSize,cellSize,cellSize);
  }
  for(const p of route){
    ctx.fillStyle="#ffe066";
    ctx.fillRect(p.c*cellSize,p.r*cellSize,cellSize,cellSize);
  }
  ctx.fillStyle="#4caf50";
  ctx.fillRect(START.c*cellSize,START.r*cellSize,cellSize,cellSize);
  ctx.fillStyle="#0277bd";
  ctx.fillRect(END.c*cellSize,END.r*cellSize,cellSize,cellSize);
}

function startAuto(){ if(timer) return; timer=setInterval(()=>{ dfsStep(); draw(); }, speed.value); }
function stopAuto(){ clearInterval(timer); timer=null; }

startBtn.onclick=()=>startAuto();
stopBtn.onclick=()=>stopAuto();
stepBtn.onclick=()=>{ dfsStep(); draw(); };
resetBtn.onclick=()=>{ stopAuto(); resetSearch(); draw(); };
regenBtn.onclick=()=>{ stopAuto(); genMaze(); resetSearch(); draw(); };
speed.oninput=()=>{ if(timer){stopAuto(); startAuto();} };

genMaze(); resetSearch(); draw();
</script>
</body>
</html>
